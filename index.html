<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>4096 - Square Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: #faf8ef;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            touch-action: none;
            overscroll-behavior: none;
        }

        .container {
            width: 100%;
            max-width: 500px;
            padding: 16px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .title {
            font-size: 64px;
            font-weight: bold;
            color: #776e65;
        }

        .scores {
            display: flex;
            gap: 8px;
        }

        .score-box {
            background: #bbada0;
            color: #fff;
            border-radius: 6px;
            padding: 8px 16px;
            text-align: center;
            min-width: 80px;
        }

        .score-box .label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .score-box .value {
            font-size: 22px;
            font-weight: bold;
        }

        .sub-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .subtitle {
            color: #776e65;
            font-size: 16px;
        }

        .buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            background: #8f7a66;
            color: #f9f6f2;
            border: none;
            border-radius: 6px;
            padding: 10px 18px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.15s;
            touch-action: manipulation;
        }

        .btn:hover {
            background: #9f8b77;
        }

        .btn-icon {
            padding: 10px 14px;
            font-size: 18px;
            line-height: 1;
        }

        .game-board {
            position: relative;
            background: #bbada0;
            border-radius: 8px;
            padding: 10px;
            width: 100%;
            aspect-ratio: 1;
        }

        .grid-bg {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            height: 100%;
        }

        .grid-cell {
            background: rgba(238, 228, 218, 0.35);
            border-radius: 6px;
        }

        .tile-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
        }

        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 6px;
            font-weight: bold;
            z-index: 10;
        }

        .tile-new {
            animation: tile-appear 0.2s ease;
        }

        .tile-merged {
            animation: tile-pop 0.2s ease;
            z-index: 20;
        }

        @keyframes tile-appear {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes tile-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #ede0c8; color: #776e65; }
        .tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile-16 { background: #f59563; color: #f9f6f2; }
        .tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile-64 { background: #f65e3b; color: #f9f6f2; }
        .tile-128 { background: #edcf72; color: #f9f6f2; }
        .tile-256 { background: #edcc61; color: #f9f6f2; }
        .tile-512 { background: #edc850; color: #f9f6f2; }
        .tile-1024 { background: #edc53f; color: #f9f6f2; }
        .tile-2048 { background: #edc22e; color: #f9f6f2; }
        .tile-4096 { background: #3c3a32; color: #f9f6f2; }
        .tile-8192 { background: #6d597a; color: #f9f6f2; }

        .overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(238, 228, 218, 0.73);
            border-radius: 8px;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .overlay.active {
            display: flex;
        }

        .overlay-message {
            font-size: 48px;
            font-weight: bold;
            color: #776e65;
            margin-bottom: 16px;
        }

        .overlay.win .overlay-message {
            color: #f9f6f2;
        }

        .overlay.win {
            background: rgba(237, 194, 46, 0.5);
        }

        /* ===== Settings Overlay ===== */
        .settings-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #faf8ef;
            z-index: 1000;
            overflow-y: auto;
        }

        .settings-overlay.active {
            display: block;
        }

        .settings-page {
            max-width: 500px;
            margin: 0 auto;
            padding: 16px;
        }

        .settings-header {
            display: flex;
            align-items: center;
            margin-bottom: 28px;
        }

        .settings-back {
            background: #8f7a66;
            color: #f9f6f2;
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.15s;
            margin-right: 16px;
            touch-action: manipulation;
        }

        .settings-back:hover {
            background: #9f8b77;
        }

        .settings-title {
            font-size: 28px;
            font-weight: bold;
            color: #776e65;
        }

        .settings-section {
            margin-bottom: 28px;
        }

        .settings-section-title {
            font-size: 18px;
            font-weight: bold;
            color: #776e65;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #bbada0;
        }

        .language-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .language-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(238, 228, 218, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            color: #776e65;
            transition: background 0.15s;
            border: 2px solid transparent;
        }

        .language-item:hover {
            background: rgba(238, 228, 218, 0.8);
        }

        .language-item.selected {
            background: #8f7a66;
            color: #f9f6f2;
            border-color: #776e65;
        }

        .language-item .check {
            display: none;
            font-size: 18px;
        }

        .language-item.selected .check {
            display: inline;
        }

        .instructions-text {
            color: #776e65;
            font-size: 15px;
            line-height: 1.8;
        }

        /* Settings main menu items */
        .settings-menu-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            background: rgba(238, 228, 218, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #776e65;
            transition: background 0.15s;
            margin-bottom: 8px;
        }

        .settings-menu-item:hover {
            background: rgba(238, 228, 218, 0.8);
        }

        .menu-arrow {
            font-size: 20px;
            color: #bbada0;
        }

        /* Sub-pages hidden by default */
        .settings-sub-page {
            display: none;
        }

        .settings-sub-page.active {
            display: block;
        }

        /* Sound toggle items */
        .sound-toggle-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sound-toggle-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(238, 228, 218, 0.5);
            border-radius: 6px;
        }

        .sound-toggle-label {
            font-size: 16px;
            color: #776e65;
        }

        .sound-toggle-btn {
            background: #bbada0;
            color: #f9f6f2;
            border: none;
            border-radius: 6px;
            padding: 8px 18px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            min-width: 60px;
            transition: background 0.15s;
            touch-action: manipulation;
        }

        .sound-toggle-btn.active {
            background: #8f7a66;
        }

        .music-style-select {
            background: #8f7a66;
            color: #f9f6f2;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            min-width: 90px;
            touch-action: manipulation;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8'%3E%3Cpath d='M1 1l5 5 5-5' stroke='%23f9f6f2' stroke-width='2' fill='none'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        /* ===== Powerup Bar ===== */
        .powerup-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 8px;
        }

        .powerup-hint {
            font-size: 13px;
            color: #776e65;
            flex: 1;
            min-height: 20px;
        }

        .powerup-hint.active {
            color: #f65e3b;
            font-weight: bold;
            animation: hint-pulse 1s ease-in-out infinite;
        }

        @keyframes hint-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .powerup-buttons {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .powerup-btn {
            position: relative;
            width: 44px;
            height: 44px;
            border: 2px solid #bbada0;
            border-radius: 10px;
            background: rgba(238, 228, 218, 0.5);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.15s;
            touch-action: manipulation;
            padding: 0;
        }

        .powerup-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .powerup-btn:not(:disabled):hover {
            background: rgba(238, 228, 218, 0.9);
            border-color: #8f7a66;
        }

        .powerup-btn.pu-active {
            border-color: #f65e3b;
            background: rgba(246, 94, 59, 0.15);
            box-shadow: 0 0 8px rgba(246, 94, 59, 0.4);
        }

        .pu-icon {
            font-size: 22px;
            line-height: 1;
        }

        .pu-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #8f7a66;
            color: #f9f6f2;
            font-size: 11px;
            font-weight: bold;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
        }

        .pu-badge.pu-zero {
            background: #cdc1b4;
        }

        .pu-cancel {
            width: 32px;
            height: 32px;
            font-size: 16px;
            font-weight: bold;
            color: #776e65;
            border-radius: 50%;
            border: 2px solid #bbada0;
        }

        /* Selection overlay on game board */
        .game-board.selecting .tile-container {
            cursor: pointer;
        }

        .game-board.selecting::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border: 3px solid #f65e3b;
            border-radius: 8px;
            pointer-events: none;
            z-index: 50;
            animation: select-border-pulse 1.2s ease-in-out infinite;
        }

        @keyframes select-border-pulse {
            0%, 100% { border-color: #f65e3b; }
            50% { border-color: #f2b179; }
        }

        .tile.tile-selected {
            box-shadow: 0 0 0 3px #f65e3b, 0 0 12px rgba(246, 94, 59, 0.5);
            z-index: 30;
        }

        @keyframes tile-demolish {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }

        .tile-demolishing {
            animation: tile-demolish 0.3s ease-out forwards;
            z-index: 30;
        }

        /* Powerup gained notification */
        @keyframes pu-gained {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-20px); opacity: 0; }
        }

        .pu-gained-anim {
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 14px;
            font-weight: bold;
            color: #f65e3b;
            pointer-events: none;
            animation: pu-gained 0.8s ease-out forwards;
        }

        .controls-panel {
            display: contents;
        }

        @media (max-width: 520px) {
            .container { padding: 10px; }
            .title { font-size: 48px; }
            .game-board { padding: 8px; }
            .grid-bg { gap: 8px; }
            .tile-container { top: 8px; left: 8px; right: 8px; bottom: 8px; }
            .settings-page { padding: 10px; }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            body {
                align-items: flex-start;
                overflow-y: auto;
            }

            .container {
                display: flex;
                flex-direction: row;
                max-width: 100%;
                padding: 8px;
                gap: 12px;
                align-items: flex-start;
            }

            .controls-panel {
                display: flex;
                flex-direction: column;
                gap: 8px;
                min-width: 120px;
                max-width: 200px;
                flex-shrink: 0;
            }

            .header {
                flex-direction: column;
                align-items: flex-start;
                margin-bottom: 8px;
            }

            .title { font-size: 36px; }

            .scores {
                flex-direction: column;
                gap: 4px;
            }

            .score-box {
                padding: 4px 8px;
                min-width: auto;
            }

            .score-box .value { font-size: 18px; }

            .sub-header {
                flex-direction: column;
                align-items: flex-start;
                margin-bottom: 0;
                gap: 6px;
            }

            .subtitle { font-size: 13px; }
            .buttons { flex-wrap: wrap; }
            .btn { padding: 6px 10px; font-size: 12px; }

            .powerup-bar {
                flex-direction: column;
                align-items: flex-start;
                margin-bottom: 4px;
                gap: 4px;
            }
            .powerup-hint { font-size: 11px; }
            .powerup-btn { width: 36px; height: 36px; }
            .pu-icon { font-size: 18px; }
            .pu-badge { width: 16px; height: 16px; font-size: 9px; top: -4px; right: -4px; }
            .pu-cancel { width: 26px; height: 26px; font-size: 13px; }

            .game-board {
                width: auto;
                height: calc(100vh - 16px);
                height: calc(100dvh - 16px);
                height: calc(var(--app-vh, 100dvh) - 16px);
                aspect-ratio: 1;
                flex-shrink: 1;
            }

            .game-board { padding: 6px; }
            .grid-bg { gap: 6px; }
            .tile-container { top: 6px; left: 6px; right: 6px; bottom: 6px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls-panel">
            <div class="header">
                <div class="title">4096</div>
                <div class="scores">
                    <div class="score-box">
                        <div class="label" id="score-label">Score</div>
                        <div class="value" id="score">0</div>
                    </div>
                    <div class="score-box">
                        <div class="label" id="best-label">Best</div>
                        <div class="value" id="best-score">0</div>
                    </div>
                </div>
            </div>
            <div class="sub-header">
                <div class="subtitle" id="subtitle">Merge tiles to reach <strong>4096</strong>!</div>
                <div class="buttons">
                    <button class="btn" id="undo-btn">Undo</button>
                    <button class="btn" id="new-game-btn">New Game</button>
                    <button class="btn btn-icon" id="settings-btn" title="Settings">âš™</button>
                </div>
            </div>
            <div class="powerup-bar" id="powerup-bar" style="display:none">
                <div class="powerup-hint" id="powerup-hint"></div>
                <div class="powerup-buttons">
                    <button class="powerup-btn" id="pu-demolish" disabled>
                        <span class="pu-icon">ğŸ’£</span>
                        <span class="pu-badge" id="pu-demolish-count">0</span>
                    </button>
                    <button class="powerup-btn" id="pu-swap" disabled>
                        <span class="pu-icon">ğŸ”„</span>
                        <span class="pu-badge" id="pu-swap-count">0</span>
                    </button>
                    <button class="powerup-btn pu-cancel" id="pu-cancel" style="display:none">âœ•</button>
                </div>
            </div>
        </div>
        <div class="game-board" id="game-board">
            <div class="grid-bg" id="grid-bg">
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            </div>
            <div class="tile-container" id="tile-container"></div>
            <div class="overlay" id="overlay">
                <div class="overlay-message" id="overlay-message"></div>
                <button class="btn" id="overlay-btn">Try Again</button>
            </div>
        </div>
    </div>

    <!-- Settings Overlay -->
    <div class="settings-overlay" id="settings-overlay">
        <div class="settings-page">
            <div class="settings-header">
                <button class="settings-back" id="settings-back">â† Back</button>
                <div class="settings-title" id="settings-title">Settings</div>
            </div>

            <!-- Main Menu -->
            <div class="settings-main-menu" id="settings-main-menu">
                <div class="settings-menu-item" id="menu-how-to-play">
                    <span id="menu-how-to-play-label">How to Play</span>
                    <span class="menu-arrow">â€º</span>
                </div>
                <div class="settings-menu-item" id="menu-sound">
                    <span id="menu-sound-label">Game Settings</span>
                    <span class="menu-arrow">â€º</span>
                </div>
                <div class="settings-menu-item" id="menu-language">
                    <span id="menu-language-label">Language</span>
                    <span class="menu-arrow">â€º</span>
                </div>
            </div>

            <!-- Sub-page: How to Play -->
            <div class="settings-sub-page" id="sub-how-to-play">
                <div class="settings-section">
                    <div class="settings-section-title" id="how-to-play-title">How to Play</div>
                    <div class="instructions-text" id="instructions-content"></div>
                </div>
            </div>

            <!-- Sub-page: Game Settings -->
            <div class="settings-sub-page" id="sub-sound">
                <div class="settings-section">
                    <div class="settings-section-title" id="sound-section-title">Game Settings</div>
                    <div class="sound-toggle-list">
                        <div class="sound-toggle-item">
                            <span class="sound-toggle-label" id="sfx-label">Sound Effects</span>
                            <button class="sound-toggle-btn" id="sfx-btn">OFF</button>
                        </div>
                        <div class="sound-toggle-item">
                            <span class="sound-toggle-label" id="music-label">Background Music</span>
                            <button class="sound-toggle-btn" id="music-btn">OFF</button>
                        </div>
                        <div class="sound-toggle-item" id="music-style-row">
                            <span class="sound-toggle-label" id="music-style-label">Style</span>
                            <select class="music-style-select" id="music-style-select">
                                <option value="serene">Serene</option>
                                <option value="upbeat">Upbeat</option>
                            </select>
                        </div>
                    </div>
                    <div class="settings-section-title" id="powerup-section-title" style="margin-top:20px">Powerup Settings</div>
                    <div class="sound-toggle-list">
                        <div class="sound-toggle-item">
                            <span class="sound-toggle-label" id="powerup-toggle-label">Power-ups</span>
                            <button class="sound-toggle-btn" id="powerup-btn">OFF</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sub-page: Language -->
            <div class="settings-sub-page" id="sub-language">
                <div class="settings-section">
                    <div class="settings-section-title" id="language-section-title">Language</div>
                    <div class="language-list" id="language-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function () {
        'use strict';

        // ===== I18N =====
        var LANG_LIST = [
            { code: 'en',    name: 'English' },
            { code: 'zh-CN', name: 'ç®€ä½“ä¸­æ–‡' },
            { code: 'zh-TW', name: 'ç¹é«”ä¸­æ–‡' },
            { code: 'ja',    name: 'æ—¥æœ¬èª' },
            { code: 'ko',    name: 'í•œêµ­ì–´' },
            { code: 'es',    name: 'EspaÃ±ol' },
            { code: 'fr',    name: 'FranÃ§ais' },
            { code: 'de',    name: 'Deutsch' },
            { code: 'pt',    name: 'PortuguÃªs' },
            { code: 'ru',    name: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹' },
            { code: 'ar',    name: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' },
            { code: 'it',    name: 'Italiano' }
        ];

        var i18n = {
            en: {
                score: 'Score',
                best: 'Best',
                subtitle: 'Merge tiles to reach <strong>4096</strong>!',
                undo: 'Undo',
                newGame: 'New Game',
                gameOver: 'Game Over!',
                youWin: 'You Win!',
                playAgain: 'Try Again',
                keepPlaying: 'Keep Playing',
                settings: 'Settings',
                language: 'Language',
                howToPlay: 'How to Play',
                back: 'Back',
                instructions: '<strong>Controls:</strong> Use <strong>Arrow Keys</strong> / <strong>WASD</strong> / <strong>Touch Swipe</strong> / <strong>Gamepad (D-pad/Stick)</strong> to move tiles. Gamepad <strong>B</strong> to undo, <strong>A</strong> to confirm.',
                gameSettings: 'Game Settings',
                powerupSettings: 'Powerup Settings',
                soundEffects: 'Sound Effects',
                backgroundMusic: 'Background Music',
                musicStyle: 'Style',
                styleSerene: 'Serene',
                styleUpbeat: 'Upbeat',
                on: 'ON',
                off: 'OFF',
                powerups: 'Power-ups',
                demolish: 'Demolish',
                swap: 'Swap',
                demolishTip: 'Remove a tile',
                swapTip: 'Swap two tiles',
                tapToSelect: 'Tap a tile',
                tapFirst: 'Tap 1st tile',
                tapSecond: 'Tap 2nd tile',
                powerupGained: '+1',
                cancelSelect: 'Cancel'
            },
            'zh-CN': {
                score: 'åˆ†æ•°',
                best: 'æœ€ä½³',
                subtitle: 'åˆå¹¶æ–¹å—ï¼Œè¾¾åˆ° <strong>4096</strong>ï¼',
                undo: 'æ’¤é”€',
                newGame: 'æ–°æ¸¸æˆ',
                gameOver: 'æ¸¸æˆç»“æŸ!',
                youWin: 'ä½ èµ¢äº†!',
                playAgain: 'å†æ¥ä¸€å±€',
                keepPlaying: 'ç»§ç»­æ¸¸æˆ',
                settings: 'è®¾ç½®',
                language: 'è¯­è¨€è®¾ç½®',
                howToPlay: 'ç©æ³•è¯´æ˜',
                back: 'è¿”å›',
                instructions: '<strong>æ“ä½œæ–¹å¼:</strong> ä½¿ç”¨ <strong>æ–¹å‘é”®</strong> / <strong>WASD</strong> / <strong>è§¦å±æ»‘åŠ¨</strong> / <strong>æ‰‹æŸ„ (åå­—é”®/æ‘‡æ†)</strong> æ§åˆ¶æ–¹å—ã€‚æ‰‹æŸ„ <strong>B</strong> é”®æ’¤é”€ï¼Œ<strong>A</strong> é”®ç¡®è®¤ã€‚',
                gameSettings: 'æ¸¸æˆè®¾ç½®',
                powerupSettings: 'é“å…·è®¾ç½®',
                soundEffects: 'éŸ³æ•ˆ',
                backgroundMusic: 'èƒŒæ™¯éŸ³ä¹',
                musicStyle: 'é£æ ¼',
                styleSerene: 'èˆ’ç¼“',
                styleUpbeat: 'æ¬¢å¿«',
                on: 'å¼€',
                off: 'å…³',
                powerups: 'é“å…·',
                demolish: 'æ¸…é™¤',
                swap: 'äº’æ¢',
                demolishTip: 'ç§»é™¤ä¸€ä¸ªæ–¹å—',
                swapTip: 'äº¤æ¢ä¸¤ä¸ªæ–¹å—',
                tapToSelect: 'ç‚¹é€‰æ–¹å—',
                tapFirst: 'ç‚¹é€‰ç¬¬1ä¸ª',
                tapSecond: 'ç‚¹é€‰ç¬¬2ä¸ª',
                powerupGained: '+1',
                cancelSelect: 'å–æ¶ˆ'
            },
            'zh-TW': {
                score: 'åˆ†æ•¸',
                best: 'æœ€ä½³',
                subtitle: 'åˆä½µæ–¹å¡Šï¼Œé”åˆ° <strong>4096</strong>ï¼',
                undo: 'æ’¤éŠ·',
                newGame: 'æ–°éŠæˆ²',
                gameOver: 'éŠæˆ²çµæŸ!',
                youWin: 'ä½ è´äº†!',
                playAgain: 'å†ä¾†ä¸€å±€',
                keepPlaying: 'ç¹¼çºŒéŠæˆ²',
                settings: 'è¨­å®š',
                language: 'èªè¨€è¨­å®š',
                howToPlay: 'ç©æ³•èªªæ˜',
                back: 'è¿”å›',
                instructions: '<strong>æ“ä½œæ–¹å¼:</strong> ä½¿ç”¨ <strong>æ–¹å‘éµ</strong> / <strong>WASD</strong> / <strong>è§¸æ§æ»‘å‹•</strong> / <strong>æ‰‹æŠŠ (åå­—éµ/æ–æ¡¿)</strong> æ§åˆ¶æ–¹å¡Šã€‚æ‰‹æŠŠ <strong>B</strong> éµæ’¤éŠ·ï¼Œ<strong>A</strong> éµç¢ºèªã€‚',
                gameSettings: 'éŠæˆ²è¨­å®š',
                powerupSettings: 'é“å…·è¨­å®š',
                soundEffects: 'éŸ³æ•ˆ',
                backgroundMusic: 'èƒŒæ™¯éŸ³æ¨‚',
                musicStyle: 'é¢¨æ ¼',
                styleSerene: 'èˆ’ç·©',
                styleUpbeat: 'æ­¡å¿«',
                on: 'é–‹',
                off: 'é—œ',
                powerups: 'é“å…·',
                demolish: 'æ¸…é™¤',
                swap: 'äº’æ›',
                demolishTip: 'ç§»é™¤ä¸€å€‹æ–¹å¡Š',
                swapTip: 'äº¤æ›å…©å€‹æ–¹å¡Š',
                tapToSelect: 'é»é¸æ–¹å¡Š',
                tapFirst: 'é»é¸ç¬¬1å€‹',
                tapSecond: 'é»é¸ç¬¬2å€‹',
                powerupGained: '+1',
                cancelSelect: 'å–æ¶ˆ'
            },
            ja: {
                score: 'ã‚¹ã‚³ã‚¢',
                best: 'ãƒ™ã‚¹ãƒˆ',
                subtitle: 'ã‚¿ã‚¤ãƒ«ã‚’åˆã‚ã›ã¦ <strong>4096</strong> ã‚’ç›®æŒ‡ãã†ï¼',
                undo: 'æˆ»ã™',
                newGame: 'æ–°è¦ã‚²ãƒ¼ãƒ ',
                gameOver: 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼!',
                youWin: 'ã‚¯ãƒªã‚¢!',
                playAgain: 'ã‚‚ã†ä¸€åº¦',
                keepPlaying: 'ç¶šã‘ã‚‹',
                settings: 'è¨­å®š',
                language: 'è¨€èª',
                howToPlay: 'éŠã³æ–¹',
                back: 'æˆ»ã‚‹',
                instructions: '<strong>æ“ä½œæ–¹æ³•:</strong> <strong>çŸ¢å°ã‚­ãƒ¼</strong> / <strong>WASD</strong> / <strong>ã‚¿ãƒƒãƒã‚¹ãƒ¯ã‚¤ãƒ—</strong> / <strong>ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ (åå­—ã‚­ãƒ¼/ã‚¹ãƒ†ã‚£ãƒƒã‚¯)</strong> ã§ã‚¿ã‚¤ãƒ«ã‚’å‹•ã‹ã—ã¾ã™ã€‚ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ <strong>B</strong> ã§å…ƒã«æˆ»ã™ã€<strong>A</strong> ã§ç¢ºèªã€‚',
                gameSettings: 'ã‚²ãƒ¼ãƒ è¨­å®š',
                powerupSettings: 'ã‚¢ã‚¤ãƒ†ãƒ è¨­å®š',
                soundEffects: 'åŠ¹æœéŸ³',
                backgroundMusic: 'BGM',
                musicStyle: 'ã‚¹ã‚¿ã‚¤ãƒ«',
                styleSerene: 'ç©ã‚„ã‹',
                styleUpbeat: 'æ˜ã‚‹ã„',
                on: 'ã‚ªãƒ³',
                off: 'ã‚ªãƒ•',
                powerups: 'ã‚¢ã‚¤ãƒ†ãƒ ',
                demolish: 'é™¤å»',
                swap: 'äº¤æ›',
                demolishTip: 'ã‚¿ã‚¤ãƒ«ã‚’é™¤å»',
                swapTip: '2ã¤ã®ã‚¿ã‚¤ãƒ«ã‚’äº¤æ›',
                tapToSelect: 'ã‚¿ã‚¤ãƒ«ã‚’é¸æŠ',
                tapFirst: '1ã¤ç›®ã‚’é¸æŠ',
                tapSecond: '2ã¤ç›®ã‚’é¸æŠ',
                powerupGained: '+1',
                cancelSelect: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«'
            },
            ko: {
                score: 'ì ìˆ˜',
                best: 'ìµœê³ ',
                subtitle: 'íƒ€ì¼ì„ í•©ì³ <strong>4096</strong>ì„ ë§Œë“œì„¸ìš”!',
                undo: 'ë˜ëŒë¦¬ê¸°',
                newGame: 'ìƒˆ ê²Œì„',
                gameOver: 'ê²Œì„ ì˜¤ë²„!',
                youWin: 'ìŠ¹ë¦¬!',
                playAgain: 'ë‹¤ì‹œí•˜ê¸°',
                keepPlaying: 'ê³„ì†í•˜ê¸°',
                settings: 'ì„¤ì •',
                language: 'ì–¸ì–´',
                howToPlay: 'ê²Œì„ ë°©ë²•',
                back: 'ë’¤ë¡œ',
                instructions: '<strong>ì¡°ì‘ ë°©ë²•:</strong> <strong>ë°©í–¥í‚¤</strong> / <strong>WASD</strong> / <strong>í„°ì¹˜ ìŠ¤ì™€ì´í”„</strong> / <strong>ê²Œì„íŒ¨ë“œ (ì‹­ìí‚¤/ìŠ¤í‹±)</strong>ë¡œ íƒ€ì¼ì„ ì´ë™í•©ë‹ˆë‹¤. ê²Œì„íŒ¨ë“œ <strong>B</strong>ë¡œ ë˜ëŒë¦¬ê¸°, <strong>A</strong>ë¡œ í™•ì¸.',
                gameSettings: 'ê²Œì„ ì„¤ì •',
                powerupSettings: 'ì•„ì´í…œ ì„¤ì •',
                soundEffects: 'íš¨ê³¼ìŒ',
                backgroundMusic: 'ë°°ê²½ ìŒì•…',
                musicStyle: 'ìŠ¤íƒ€ì¼',
                styleSerene: 'ì”ì”í•œ',
                styleUpbeat: 'ì‹ ë‚˜ëŠ”',
                on: 'ì¼œê¸°',
                off: 'ë„ê¸°',
                powerups: 'ì•„ì´í…œ',
                demolish: 'ì œê±°',
                swap: 'êµí™˜',
                demolishTip: 'íƒ€ì¼ ì œê±°',
                swapTip: 'íƒ€ì¼ 2ê°œ êµí™˜',
                tapToSelect: 'íƒ€ì¼ ì„ íƒ',
                tapFirst: 'ì²« ë²ˆì§¸ ì„ íƒ',
                tapSecond: 'ë‘ ë²ˆì§¸ ì„ íƒ',
                powerupGained: '+1',
                cancelSelect: 'ì·¨ì†Œ'
            },
            es: {
                score: 'Puntos',
                best: 'Mejor',
                subtitle: 'Â¡Combina fichas para llegar a <strong>4096</strong>!',
                undo: 'Deshacer',
                newGame: 'Nuevo juego',
                gameOver: 'Â¡Fin del juego!',
                youWin: 'Â¡Ganaste!',
                playAgain: 'Intentar de nuevo',
                keepPlaying: 'Seguir jugando',
                settings: 'Ajustes',
                language: 'Idioma',
                howToPlay: 'CÃ³mo jugar',
                back: 'Volver',
                instructions: '<strong>Controles:</strong> Usa las <strong>Teclas de direcciÃ³n</strong> / <strong>WASD</strong> / <strong>Deslizar en pantalla</strong> / <strong>Mando (cruceta/joystick)</strong> para mover las fichas. Mando <strong>B</strong> para deshacer, <strong>A</strong> para confirmar.',
                gameSettings: 'Juego',
                powerupSettings: 'Poderes',
                soundEffects: 'Efectos de sonido',
                backgroundMusic: 'MÃºsica de fondo',
                musicStyle: 'Estilo',
                styleSerene: 'Sereno',
                styleUpbeat: 'Animado',
                on: 'SÃ',
                off: 'NO',
                powerups: 'Poderes',
                demolish: 'Demoler',
                swap: 'Intercambiar',
                demolishTip: 'Eliminar una ficha',
                swapTip: 'Intercambiar dos fichas',
                tapToSelect: 'Toca una ficha',
                tapFirst: 'Toca la 1Âª ficha',
                tapSecond: 'Toca la 2Âª ficha',
                powerupGained: '+1',
                cancelSelect: 'Cancelar'
            },
            fr: {
                score: 'Score',
                best: 'Meilleur',
                subtitle: 'Fusionnez les tuiles pour atteindre <strong>4096</strong> !',
                undo: 'Annuler',
                newGame: 'Nouvelle partie',
                gameOver: 'Partie terminÃ©e !',
                youWin: 'Vous avez gagnÃ© !',
                playAgain: 'Rejouer',
                keepPlaying: 'Continuer',
                settings: 'ParamÃ¨tres',
                language: 'Langue',
                howToPlay: 'Comment jouer',
                back: 'Retour',
                instructions: '<strong>Commandes :</strong> Utilisez les <strong>Touches flÃ©chÃ©es</strong> / <strong>WASD</strong> / <strong>Glisser sur l\'Ã©cran</strong> / <strong>Manette (croix directionnelle/joystick)</strong> pour dÃ©placer les tuiles. Manette <strong>B</strong> pour annuler, <strong>A</strong> pour confirmer.',
                gameSettings: 'Jeu',
                powerupSettings: 'Bonus',
                soundEffects: 'Effets sonores',
                backgroundMusic: 'Musique de fond',
                musicStyle: 'Style',
                styleSerene: 'Serein',
                styleUpbeat: 'EntraÃ®nant',
                on: 'OUI',
                off: 'NON',
                powerups: 'Bonus',
                demolish: 'DÃ©truire',
                swap: 'Ã‰changer',
                demolishTip: 'Supprimer une tuile',
                swapTip: 'Ã‰changer deux tuiles',
                tapToSelect: 'Touchez une tuile',
                tapFirst: 'Touchez la 1Ã¨re',
                tapSecond: 'Touchez la 2Ã¨me',
                powerupGained: '+1',
                cancelSelect: 'Annuler'
            },
            de: {
                score: 'Punkte',
                best: 'Beste',
                subtitle: 'Verbinde Kacheln, um <strong>4096</strong> zu erreichen!',
                undo: 'RÃ¼ckgÃ¤ngig',
                newGame: 'Neues Spiel',
                gameOver: 'Spiel vorbei!',
                youWin: 'Du hast gewonnen!',
                playAgain: 'Nochmal',
                keepPlaying: 'Weiterspielen',
                settings: 'Einstellungen',
                language: 'Sprache',
                howToPlay: 'Spielanleitung',
                back: 'ZurÃ¼ck',
                instructions: '<strong>Steuerung:</strong> Verwende <strong>Pfeiltasten</strong> / <strong>WASD</strong> / <strong>Wischen</strong> / <strong>Gamepad (Steuerkreuz/Stick)</strong> zum Bewegen der Kacheln. Gamepad <strong>B</strong> zum RÃ¼ckgÃ¤ngigmachen, <strong>A</strong> zum BestÃ¤tigen.',
                gameSettings: 'Spieleinstellungen',
                powerupSettings: 'Power-up-Einstellungen',
                soundEffects: 'Soundeffekte',
                backgroundMusic: 'Hintergrundmusik',
                musicStyle: 'Stil',
                styleSerene: 'Ruhig',
                styleUpbeat: 'FrÃ¶hlich',
                on: 'AN',
                off: 'AUS',
                powerups: 'Power-ups',
                demolish: 'Entfernen',
                swap: 'Tauschen',
                demolishTip: 'Kachel entfernen',
                swapTip: 'Zwei Kacheln tauschen',
                tapToSelect: 'Kachel antippen',
                tapFirst: '1. Kachel antippen',
                tapSecond: '2. Kachel antippen',
                powerupGained: '+1',
                cancelSelect: 'Abbrechen'
            },
            pt: {
                score: 'Pontos',
                best: 'Melhor',
                subtitle: 'Combine as peÃ§as para chegar a <strong>4096</strong>!',
                undo: 'Desfazer',
                newGame: 'Novo jogo',
                gameOver: 'Fim de jogo!',
                youWin: 'VocÃª venceu!',
                playAgain: 'Tentar novamente',
                keepPlaying: 'Continuar',
                settings: 'ConfiguraÃ§Ãµes',
                language: 'Idioma',
                howToPlay: 'Como jogar',
                back: 'Voltar',
                instructions: '<strong>Controles:</strong> Use as <strong>Setas</strong> / <strong>WASD</strong> / <strong>Deslize na tela</strong> / <strong>Controle (direcional/analÃ³gico)</strong> para mover as peÃ§as. Controle <strong>B</strong> para desfazer, <strong>A</strong> para confirmar.',
                gameSettings: 'Jogo',
                powerupSettings: 'Poderes',
                soundEffects: 'Efeitos sonoros',
                backgroundMusic: 'MÃºsica de fundo',
                musicStyle: 'Estilo',
                styleSerene: 'Sereno',
                styleUpbeat: 'Animado',
                on: 'SIM',
                off: 'NÃƒO',
                powerups: 'Poderes',
                demolish: 'Demolir',
                swap: 'Trocar',
                demolishTip: 'Remover uma peÃ§a',
                swapTip: 'Trocar duas peÃ§as',
                tapToSelect: 'Toque uma peÃ§a',
                tapFirst: 'Toque a 1Âª peÃ§a',
                tapSecond: 'Toque a 2Âª peÃ§a',
                powerupGained: '+1',
                cancelSelect: 'Cancelar'
            },
            ru: {
                score: 'Ğ¡Ñ‡Ñ‘Ñ‚',
                best: 'Ğ›ÑƒÑ‡ÑˆĞ¸Ğ¹',
                subtitle: 'ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½ÑĞ¹Ñ‚Ğµ Ğ¿Ğ»Ğ¸Ñ‚ĞºĞ¸, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ <strong>4096</strong>!',
                undo: 'ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ',
                newGame: 'ĞĞ¾Ğ²Ğ°Ñ Ğ¸Ğ³Ñ€Ğ°',
                gameOver: 'Ğ˜Ğ³Ñ€Ğ° Ğ¾ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ°!',
                youWin: 'Ğ’Ñ‹ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ»Ğ¸!',
                playAgain: 'Ğ—Ğ°Ğ½Ğ¾Ğ²Ğ¾',
                keepPlaying: 'ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ',
                settings: 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸',
                language: 'Ğ¯Ğ·Ñ‹Ğº',
                howToPlay: 'ĞšĞ°Ğº Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ',
                back: 'ĞĞ°Ğ·Ğ°Ğ´',
                instructions: '<strong>Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ:</strong> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ <strong>Ğ¡Ñ‚Ñ€ĞµĞ»ĞºĞ¸</strong> / <strong>WASD</strong> / <strong>Ğ¡Ğ²Ğ°Ğ¹Ğ¿</strong> / <strong>Ğ“ĞµĞ¹Ğ¼Ğ¿Ğ°Ğ´ (ĞºÑ€ĞµÑÑ‚Ğ¾Ğ²Ğ¸Ğ½Ğ°/ÑÑ‚Ğ¸Ğº)</strong> Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ Ğ¿Ğ»Ğ¸Ñ‚Ğ¾Ğº. Ğ“ĞµĞ¹Ğ¼Ğ¿Ğ°Ğ´ <strong>B</strong> â€” Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ°, <strong>A</strong> â€” Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ.',
                gameSettings: 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¸Ğ³Ñ€Ñ‹',
                powerupSettings: 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ±Ğ¾Ğ½ÑƒÑĞ¾Ğ²',
                soundEffects: 'Ğ—Ğ²ÑƒĞºĞ¾Ğ²Ñ‹Ğµ ÑÑ„Ñ„ĞµĞºÑ‚Ñ‹',
                backgroundMusic: 'Ğ¤Ğ¾Ğ½Ğ¾Ğ²Ğ°Ñ Ğ¼ÑƒĞ·Ñ‹ĞºĞ°',
                musicStyle: 'Ğ¡Ñ‚Ğ¸Ğ»ÑŒ',
                styleSerene: 'Ğ¡Ğ¿Ğ¾ĞºĞ¾Ğ¹Ğ½Ñ‹Ğ¹',
                styleUpbeat: 'Ğ’ĞµÑÑ‘Ğ»Ñ‹Ğ¹',
                on: 'Ğ’ĞšĞ›',
                off: 'Ğ’Ğ«ĞšĞ›',
                powerups: 'Ğ‘Ğ¾Ğ½ÑƒÑÑ‹',
                demolish: 'Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ',
                swap: 'ĞĞ±Ğ¼ĞµĞ½ÑÑ‚ÑŒ',
                demolishTip: 'Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ»Ğ¸Ñ‚ĞºÑƒ',
                swapTip: 'ĞĞ±Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ´Ğ²Ğµ Ğ¿Ğ»Ğ¸Ñ‚ĞºĞ¸',
                tapToSelect: 'ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ½Ğ° Ğ¿Ğ»Ğ¸Ñ‚ĞºÑƒ',
                tapFirst: 'Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ 1-Ñ',
                tapSecond: 'Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ 2-Ñ',
                powerupGained: '+1',
                cancelSelect: 'ĞÑ‚Ğ¼ĞµĞ½Ğ°'
            },
            ar: {
                score: 'Ø§Ù„Ù†Ù‚Ø§Ø·',
                best: 'Ø§Ù„Ø£ÙØ¶Ù„',
                subtitle: 'Ø§Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ <strong>4096</strong>!',
                undo: 'ØªØ±Ø§Ø¬Ø¹',
                newGame: 'Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©',
                gameOver: 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!',
                youWin: 'ÙØ²Øª!',
                playAgain: 'Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©',
                keepPlaying: 'Ø§Ø³ØªÙ…Ø±',
                settings: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
                language: 'Ø§Ù„Ù„ØºØ©',
                howToPlay: 'Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù„Ø¹Ø¨',
                back: 'Ø±Ø¬ÙˆØ¹',
                instructions: '<strong>Ø§Ù„ØªØ­ÙƒÙ…:</strong> Ø§Ø³ØªØ®Ø¯Ù… <strong>Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ù‡Ù…</strong> / <strong>WASD</strong> / <strong>Ø§Ù„Ø³Ø­Ø¨ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©</strong> / <strong>Ø°Ø±Ø§Ø¹ Ø§Ù„ØªØ­ÙƒÙ… (Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ÙŠØ©/Ø§Ù„Ø¹ØµØ§)</strong> Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª. Ø²Ø± <strong>B</strong> Ù„Ù„ØªØ±Ø§Ø¬Ø¹ØŒ Ø²Ø± <strong>A</strong> Ù„Ù„ØªØ£ÙƒÙŠØ¯.',
                gameSettings: 'Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©',
                powerupSettings: 'Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø¯ÙˆØ§Øª',
                soundEffects: 'Ø§Ù„Ù…Ø¤Ø«Ø±Ø§Øª Ø§Ù„ØµÙˆØªÙŠØ©',
                backgroundMusic: 'Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ©',
                musicStyle: 'Ø§Ù„Ù†Ù…Ø·',
                styleSerene: 'Ù‡Ø§Ø¯Ø¦',
                styleUpbeat: 'Ù…Ø±Ø­',
                on: 'ØªØ´ØºÙŠÙ„',
                off: 'Ø¥ÙŠÙ‚Ø§Ù',
                powerups: 'Ø£Ø¯ÙˆØ§Øª',
                demolish: 'Ø¥Ø²Ø§Ù„Ø©',
                swap: 'ØªØ¨Ø¯ÙŠÙ„',
                demolishTip: 'Ø¥Ø²Ø§Ù„Ø© Ù…Ø±Ø¨Ø¹',
                swapTip: 'ØªØ¨Ø¯ÙŠÙ„ Ù…Ø±Ø¨Ø¹ÙŠÙ†',
                tapToSelect: 'Ø§Ø®ØªØ± Ù…Ø±Ø¨Ø¹Ø§Ù‹',
                tapFirst: 'Ø§Ø®ØªØ± Ø§Ù„Ø£ÙˆÙ„',
                tapSecond: 'Ø§Ø®ØªØ± Ø§Ù„Ø«Ø§Ù†ÙŠ',
                powerupGained: '+1',
                cancelSelect: 'Ø¥Ù„ØºØ§Ø¡'
            },
            it: {
                score: 'Punti',
                best: 'Migliore',
                subtitle: 'Unisci le tessere per raggiungere <strong>4096</strong>!',
                undo: 'Annulla',
                newGame: 'Nuova partita',
                gameOver: 'Game Over!',
                youWin: 'Hai vinto!',
                playAgain: 'Riprova',
                keepPlaying: 'Continua',
                settings: 'Impostazioni',
                language: 'Lingua',
                howToPlay: 'Come giocare',
                back: 'Indietro',
                instructions: '<strong>Comandi:</strong> Usa i <strong>Tasti freccia</strong> / <strong>WASD</strong> / <strong>Scorri sullo schermo</strong> / <strong>Controller (croce direzionale/stick)</strong> per muovere le tessere. Controller <strong>B</strong> per annullare, <strong>A</strong> per confermare.',
                gameSettings: 'Impostazioni gioco',
                powerupSettings: 'Impostazioni potenziamenti',
                soundEffects: 'Effetti sonori',
                backgroundMusic: 'Musica di sottofondo',
                musicStyle: 'Stile',
                styleSerene: 'Sereno',
                styleUpbeat: 'Allegro',
                on: 'SÃŒ',
                off: 'NO',
                powerups: 'Potenziamenti',
                demolish: 'Rimuovi',
                swap: 'Scambia',
                demolishTip: 'Rimuovi una tessera',
                swapTip: 'Scambia due tessere',
                tapToSelect: 'Tocca una tessera',
                tapFirst: 'Tocca la 1Âª',
                tapSecond: 'Tocca la 2Âª',
                powerupGained: '+1',
                cancelSelect: 'Annulla'
            }
        };

        var currentLang = 'en';

        function t(key) {
            return i18n[currentLang][key] || i18n.en[key] || key;
        }

        // Detect language: check saved â†’ browser languages â†’ OS language â†’ fallback to English
        function detectLanguage() {
            // 1. Check saved preference
            var saved = localStorage.getItem('game4096_lang');
            if (saved && i18n[saved]) return saved;

            // 2. Check browser/OS languages
            var languages = navigator.languages || [navigator.language || navigator.userLanguage || ''];
            for (var i = 0; i < languages.length; i++) {
                var lang = languages[i];
                // Exact match
                if (i18n[lang]) return lang;
                // Handle zh variants
                if (lang === 'zh-Hans' || lang.indexOf('zh-Hans') === 0 || lang === 'zh-CN') return 'zh-CN';
                if (lang === 'zh-Hant' || lang.indexOf('zh-Hant') === 0 || lang === 'zh-TW' || lang === 'zh-HK') return 'zh-TW';
                if (lang === 'zh') return 'zh-CN';
                // Prefix match (e.g. "en-US" â†’ "en", "ja-JP" â†’ "ja")
                var prefix = lang.split('-')[0];
                if (i18n[prefix]) return prefix;
            }

            // 3. Fallback to English
            return 'en';
        }

        // Apply language to all UI elements
        function applyLanguage(langCode) {
            currentLang = langCode;
            localStorage.setItem('game4096_lang', langCode);
            document.documentElement.lang = langCode;

            // Game UI
            document.getElementById('score-label').textContent = t('score');
            document.getElementById('best-label').textContent = t('best');
            document.getElementById('subtitle').innerHTML = t('subtitle');
            document.getElementById('undo-btn').textContent = t('undo');
            document.getElementById('new-game-btn').textContent = t('newGame');

            // Overlay â€” update based on current game state
            if (over && !won) {
                overlayMessage.textContent = t('gameOver');
                overlayBtn.textContent = t('playAgain');
            } else if (won && !keepPlaying) {
                overlayMessage.textContent = t('youWin');
                overlayBtn.textContent = t('keepPlaying');
            } else {
                overlayBtn.textContent = t('playAgain');
            }

            // Settings UI
            document.getElementById('settings-back').textContent = 'â† ' + t('back');
            document.getElementById('language-section-title').textContent = t('language');
            document.getElementById('how-to-play-title').textContent = t('howToPlay');
            document.getElementById('instructions-content').innerHTML = t('instructions');
            document.getElementById('settings-btn').title = t('settings');

            // Settings menu items
            document.getElementById('menu-how-to-play-label').textContent = t('howToPlay');
            document.getElementById('menu-sound-label').textContent = t('gameSettings');
            document.getElementById('menu-language-label').textContent = t('language');

            // Sound sub-page
            document.getElementById('sound-section-title').textContent = t('gameSettings');
            document.getElementById('sfx-label').textContent = t('soundEffects');
            document.getElementById('music-label').textContent = t('backgroundMusic');
            document.getElementById('music-style-label').textContent = t('musicStyle');
            document.getElementById('powerup-section-title').textContent = t('powerupSettings');
            document.getElementById('powerup-toggle-label').textContent = t('powerups');
            document.getElementById('pu-demolish').title = t('demolishTip');
            document.getElementById('pu-swap').title = t('swapTip');
            updateSoundUI();
            updatePowerupBar();

            // Update settings title based on current sub-page
            if (settingsSubPage === 'how-to-play') {
                document.getElementById('settings-title').textContent = t('howToPlay');
            } else if (settingsSubPage === 'sound') {
                document.getElementById('settings-title').textContent = t('gameSettings');
            } else if (settingsSubPage === 'language') {
                document.getElementById('settings-title').textContent = t('language');
            } else {
                document.getElementById('settings-title').textContent = t('settings');
            }

            renderLanguageList();
        }

        function renderLanguageList() {
            var list = document.getElementById('language-list');
            list.innerHTML = '';
            for (var i = 0; i < LANG_LIST.length; i++) {
                var lang = LANG_LIST[i];
                var item = document.createElement('div');
                item.className = 'language-item' + (lang.code === currentLang ? ' selected' : '');
                item.setAttribute('data-lang', lang.code);
                item.innerHTML = '<span>' + lang.name + '</span><span class="check">âœ“</span>';
                item.addEventListener('click', (function (code) {
                    return function () {
                        applyLanguage(code);
                    };
                })(lang.code));
                list.appendChild(item);
            }
        }

        // ===== Settings =====
        var settingsOpen = false;
        var settingsSubPage = null; // null = main menu, or 'how-to-play' | 'sound' | 'language'
        var settingsOverlay = document.getElementById('settings-overlay');
        var settingsBtn = document.getElementById('settings-btn');
        var settingsBackBtn = document.getElementById('settings-back');
        var settingsMainMenu = document.getElementById('settings-main-menu');

        var subPages = {
            'how-to-play': document.getElementById('sub-how-to-play'),
            'sound': document.getElementById('sub-sound'),
            'language': document.getElementById('sub-language')
        };

        function openSettings() {
            settingsOpen = true;
            settingsSubPage = null;
            settingsMainMenu.style.display = '';
            for (var key in subPages) subPages[key].classList.remove('active');
            document.getElementById('settings-title').textContent = t('settings');
            settingsOverlay.classList.add('active');
        }

        function closeSettings() {
            settingsOpen = false;
            settingsSubPage = null;
            settingsOverlay.classList.remove('active');
        }

        function openSubPage(page) {
            settingsSubPage = page;
            settingsMainMenu.style.display = 'none';
            for (var key in subPages) subPages[key].classList.remove('active');
            subPages[page].classList.add('active');

            var titleMap = {
                'how-to-play': t('howToPlay'),
                'sound': t('gameSettings'),
                'language': t('language')
            };
            document.getElementById('settings-title').textContent = titleMap[page] || t('settings');
        }

        function settingsBack() {
            if (settingsSubPage) {
                settingsSubPage = null;
                settingsMainMenu.style.display = '';
                for (var key in subPages) subPages[key].classList.remove('active');
                document.getElementById('settings-title').textContent = t('settings');
            } else {
                closeSettings();
            }
        }

        settingsBtn.addEventListener('click', openSettings);
        settingsBackBtn.addEventListener('click', settingsBack);
        document.getElementById('menu-how-to-play').addEventListener('click', function () { openSubPage('how-to-play'); });
        document.getElementById('menu-sound').addEventListener('click', function () { openSubPage('sound'); });
        document.getElementById('menu-language').addEventListener('click', function () { openSubPage('language'); });

        // ===== Audio =====
        var audioCtx = null;
        var sfxEnabled = localStorage.getItem('game4096_sfx') === 'true';
        var musicEnabled = localStorage.getItem('game4096_music') === 'true';
        var bgMusicNodes = null;
        var bgMusicTimer = null;

        function ensureAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            return audioCtx;
        }

        // --- Move sound effect (synthesized pop) ---
        function playMoveSFX() {
            if (!sfxEnabled) return;
            try {
                var ctx = ensureAudioContext();
                var osc = ctx.createOscillator();
                var gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(660, ctx.currentTime + 0.06);
                gain.gain.setValueAtTime(0.15, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            } catch (e) { /* ignore audio errors */ }
        }

        // --- Procedural background music (two styles) ---
        var BGM_STYLES = {
            serene: {
                // Cmaj7 â†’ Am7 â†’ Fmaj7 â†’ G7 (healing/soothing)
                chords: [
                    [261.63, 329.63, 392.00, 493.88],
                    [220.00, 261.63, 329.63, 392.00],
                    [174.61, 220.00, 261.63, 329.63],
                    [196.00, 246.94, 293.66, 349.23]
                ],
                chordDuration: 4,
                fadeDuration: 1.5,
                filterFreq: 800,
                masterVol: 0.12,
                oscTypes: ['sine', 'triangle'],
                oscGains: [0.08, 0.03],
                detune: 0.002,
                arpeggio: false
            },
            upbeat: {
                // C â†’ G â†’ Am â†’ F (uplifting pop progression)
                // then D â†’ A â†’ Bm â†’ G (bright key change)
                chords: [
                    [261.63, 329.63, 392.00],   // C:  C4 E4 G4
                    [196.00, 246.94, 392.00],   // G:  G3 B3 G4
                    [220.00, 261.63, 329.63],   // Am: A3 C4 E4
                    [174.61, 220.00, 261.63],   // F:  F3 A3 C4
                    [293.66, 369.99, 440.00],   // D:  D4 F#4 A4
                    [220.00, 277.18, 329.63],   // A:  A3 C#4 E4
                    [246.94, 293.66, 369.99],   // Bm: B3 D4 F#4
                    [196.00, 246.94, 392.00]    // G:  G3 B3 G4
                ],
                chordDuration: 2,
                fadeDuration: 0.4,
                filterFreq: 2500,
                masterVol: 0.10,
                oscTypes: ['triangle', 'square'],
                oscGains: [0.07, 0.015],
                detune: 0.003,
                arpeggio: true
            }
        };

        var currentBgmStyle = localStorage.getItem('game4096_bgmStyle') || 'serene';

        function startBgMusic() {
            if (!musicEnabled) return;
            if (bgMusicNodes) return; // already playing
            try {
                var ctx = ensureAudioContext();
                var style = BGM_STYLES[currentBgmStyle] || BGM_STYLES.serene;

                var masterGain = ctx.createGain();
                masterGain.gain.value = style.masterVol;

                var filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = style.filterFreq;
                filter.Q.value = 0.5;

                filter.connect(masterGain);
                masterGain.connect(ctx.destination);

                bgMusicNodes = { ctx: ctx, masterGain: masterGain, filter: filter, oscs: [] };

                function scheduleChordCycle() {
                    if (!bgMusicNodes) return;
                    var ctx = bgMusicNodes.ctx;
                    var now = ctx.currentTime;
                    var chords = style.chords;
                    var chordDur = style.chordDuration;
                    var fadeDur = style.fadeDuration;

                    for (var c = 0; c < chords.length; c++) {
                        var chord = chords[c];
                        var chordStart = now + c * chordDur;

                        for (var n = 0; n < chord.length; n++) {
                            // Arpeggio: stagger note start times within the chord
                            var noteDelay = style.arpeggio ? n * 0.15 : 0;
                            var noteStart = chordStart + noteDelay;
                            var noteDur = chordDur - noteDelay;

                            for (var d = 0; d < style.oscTypes.length; d++) {
                                var osc = ctx.createOscillator();
                                var noteGain = ctx.createGain();

                                osc.type = style.oscTypes[d];
                                osc.frequency.value = chord[n] * (1 + (d === 0 ? style.detune : -style.detune));

                                var peakGain = style.oscGains[d];
                                noteGain.gain.setValueAtTime(0.001, noteStart);
                                noteGain.gain.exponentialRampToValueAtTime(peakGain, noteStart + fadeDur);
                                noteGain.gain.setValueAtTime(peakGain, noteStart + noteDur - fadeDur);
                                noteGain.gain.exponentialRampToValueAtTime(0.001, noteStart + noteDur);

                                osc.connect(noteGain);
                                noteGain.connect(bgMusicNodes.filter);

                                osc.start(noteStart);
                                osc.stop(noteStart + noteDur + 0.1);
                                bgMusicNodes.oscs.push(osc);
                            }
                        }
                    }

                    var cycleDuration = chords.length * chordDur * 1000;
                    bgMusicTimer = setTimeout(function () {
                        if (bgMusicNodes) {
                            bgMusicNodes.oscs = [];
                            scheduleChordCycle();
                        }
                    }, cycleDuration - 200);
                }

                scheduleChordCycle();
            } catch (e) { /* ignore audio errors */ }
        }

        function stopBgMusic() {
            if (bgMusicTimer) {
                clearTimeout(bgMusicTimer);
                bgMusicTimer = null;
            }
            if (bgMusicNodes) {
                try {
                    for (var i = 0; i < bgMusicNodes.oscs.length; i++) {
                        try { bgMusicNodes.oscs[i].stop(); } catch (e) {}
                    }
                    bgMusicNodes.masterGain.disconnect();
                    bgMusicNodes.filter.disconnect();
                } catch (e) {}
                bgMusicNodes = null;
            }
        }

        // --- Sound toggle controls ---
        function toggleSFX() {
            sfxEnabled = !sfxEnabled;
            localStorage.setItem('game4096_sfx', sfxEnabled);
            updateSoundUI();
            if (sfxEnabled) playMoveSFX(); // feedback sound
        }

        function toggleMusic() {
            musicEnabled = !musicEnabled;
            localStorage.setItem('game4096_music', musicEnabled);
            updateSoundUI();
            if (musicEnabled) {
                startBgMusic();
            } else {
                stopBgMusic();
            }
        }

        function changeBgmStyle(newStyle) {
            if (newStyle === currentBgmStyle) return;
            currentBgmStyle = newStyle;
            localStorage.setItem('game4096_bgmStyle', newStyle);
            // Restart music with new style if currently playing
            if (musicEnabled && bgMusicNodes) {
                stopBgMusic();
                startBgMusic();
            }
        }

        function updateSoundUI() {
            var sfxBtn = document.getElementById('sfx-btn');
            var musicBtn = document.getElementById('music-btn');
            var styleSelect = document.getElementById('music-style-select');
            var puBtn = document.getElementById('powerup-btn');
            sfxBtn.textContent = sfxEnabled ? t('on') : t('off');
            sfxBtn.className = 'sound-toggle-btn' + (sfxEnabled ? ' active' : '');
            musicBtn.textContent = musicEnabled ? t('on') : t('off');
            musicBtn.className = 'sound-toggle-btn' + (musicEnabled ? ' active' : '');
            puBtn.textContent = powerupsEnabled ? t('on') : t('off');
            puBtn.className = 'sound-toggle-btn' + (powerupsEnabled ? ' active' : '');
            // Update dropdown value and option labels
            styleSelect.value = currentBgmStyle;
            styleSelect.options[0].textContent = t('styleSerene');
            styleSelect.options[1].textContent = t('styleUpbeat');
        }

        document.getElementById('sfx-btn').addEventListener('click', toggleSFX);
        document.getElementById('music-btn').addEventListener('click', toggleMusic);
        document.getElementById('music-style-select').addEventListener('change', function () {
            changeBgmStyle(this.value);
        });

        // --- Mobile audio unlock (resume on first interaction) ---
        var audioUnlocked = false;
        function unlockAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            if (musicEnabled && !bgMusicNodes) {
                startBgMusic();
            }
        }
        document.addEventListener('touchstart', unlockAudio, { once: true });
        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('keydown', unlockAudio, { once: true });

        // ===== Power-ups =====
        var powerupsEnabled = localStorage.getItem('game4096_powerups') === 'true';
        var puState = { demolish: 0, swap: 2, lastScoreMilestone: 0 };
        var puSelectMode = null;   // null | 'demolish' | 'swap'
        var puSwapFirst = null;    // [row, col] of first selected tile for swap

        var puBar = document.getElementById('powerup-bar');
        var puHint = document.getElementById('powerup-hint');
        var puDemolishBtn = document.getElementById('pu-demolish');
        var puSwapBtn = document.getElementById('pu-swap');
        var puCancelBtn = document.getElementById('pu-cancel');

        function togglePowerups() {
            powerupsEnabled = !powerupsEnabled;
            localStorage.setItem('game4096_powerups', powerupsEnabled);
            updateSoundUI();
            updatePowerupBar();
        }

        function updatePowerupBar() {
            puBar.style.display = powerupsEnabled ? 'flex' : 'none';
            if (!powerupsEnabled) {
                cancelPuSelect();
                return;
            }
            // Update counts
            document.getElementById('pu-demolish-count').textContent = puState.demolish;
            document.getElementById('pu-demolish-count').className = 'pu-badge' + (puState.demolish === 0 ? ' pu-zero' : '');
            document.getElementById('pu-swap-count').textContent = puState.swap;
            document.getElementById('pu-swap-count').className = 'pu-badge' + (puState.swap === 0 ? ' pu-zero' : '');

            // Enable/disable buttons
            puDemolishBtn.disabled = puState.demolish <= 0 || puSelectMode === 'swap';
            puSwapBtn.disabled = puState.swap <= 0 || puSelectMode === 'demolish';

            // Active state
            puDemolishBtn.classList.toggle('pu-active', puSelectMode === 'demolish');
            puSwapBtn.classList.toggle('pu-active', puSelectMode === 'swap');

            // Cancel button visibility
            puCancelBtn.style.display = puSelectMode ? 'flex' : 'none';

            // Hint text
            if (puSelectMode === 'demolish') {
                puHint.textContent = t('tapToSelect');
                puHint.className = 'powerup-hint active';
            } else if (puSelectMode === 'swap') {
                puHint.textContent = puSwapFirst ? t('tapSecond') : t('tapFirst');
                puHint.className = 'powerup-hint active';
            } else {
                puHint.textContent = '';
                puHint.className = 'powerup-hint';
            }
        }

        function startPuSelect(type) {
            if (animating) return;
            if (over && !keepPlaying) return;
            if (puSelectMode === type) { cancelPuSelect(); return; }
            puSelectMode = type;
            puSwapFirst = null;
            gameBoard.classList.add('selecting');
            updatePowerupBar();
        }

        function cancelPuSelect() {
            puSelectMode = null;
            puSwapFirst = null;
            gameBoard.classList.remove('selecting');
            // Remove any tile-selected classes
            var selected = tileContainer.querySelectorAll('.tile-selected');
            for (var i = 0; i < selected.length; i++) selected[i].classList.remove('tile-selected');
            updatePowerupBar();
        }

        function handleTileClick(r, c) {
            if (!puSelectMode) return;
            if (grid[r][c] === 0) return; // can't select empty cell

            if (puSelectMode === 'demolish') {
                executeDemolish(r, c);
            } else if (puSelectMode === 'swap') {
                if (!puSwapFirst) {
                    puSwapFirst = [r, c];
                    // Mark the tile as selected visually
                    highlightTile(r, c);
                    updatePowerupBar(); // update hint to "tap second"
                } else {
                    if (puSwapFirst[0] === r && puSwapFirst[1] === c) return; // same tile
                    executeSwap(puSwapFirst[0], puSwapFirst[1], r, c);
                }
            }
        }

        function highlightTile(r, c) {
            var tiles = tileContainer.children;
            for (var i = 0; i < tiles.length; i++) {
                var el = tiles[i];
                var pos = tilePos(r, c);
                var elTop = parseFloat(el.style.top);
                var elLeft = parseFloat(el.style.left);
                if (Math.abs(elTop - pos.top) < 2 && Math.abs(elLeft - pos.left) < 2) {
                    el.classList.add('tile-selected');
                    break;
                }
            }
        }

        function executeDemolish(r, c) {
            // Find the tile element and animate it
            var tiles = tileContainer.children;
            var pos = tilePos(r, c);
            for (var i = 0; i < tiles.length; i++) {
                var el = tiles[i];
                var elTop = parseFloat(el.style.top);
                var elLeft = parseFloat(el.style.left);
                if (Math.abs(elTop - pos.top) < 2 && Math.abs(elLeft - pos.left) < 2) {
                    el.classList.add('tile-demolishing');
                    break;
                }
            }

            // Save undo state
            previousState = { grid: cloneGrid(grid), score: score, puState: JSON.parse(JSON.stringify(puState)) };

            // Remove tile from grid
            grid[r][c] = 0;
            puState.demolish--;
            puSelectMode = null;
            gameBoard.classList.remove('selecting');

            setTimeout(function () {
                renderTiles(null, null);
                updatePowerupBar();
                savePuState();
                saveState();
            }, 300);
        }

        function executeSwap(r1, c1, r2, c2) {
            // Save undo state
            previousState = { grid: cloneGrid(grid), score: score, puState: JSON.parse(JSON.stringify(puState)) };

            // Animate: move tiles to each other's positions
            animating = true;
            var tiles = tileContainer.children;
            var pos1 = tilePos(r1, c1);
            var pos2 = tilePos(r2, c2);
            var transVal = 'top 200ms ease-in-out, left 200ms ease-in-out';

            for (var i = 0; i < tiles.length; i++) {
                var el = tiles[i];
                var elTop = parseFloat(el.style.top);
                var elLeft = parseFloat(el.style.left);
                el.style.transition = transVal;
                if (Math.abs(elTop - pos1.top) < 2 && Math.abs(elLeft - pos1.left) < 2) {
                    el.style.top = pos2.top + 'px';
                    el.style.left = pos2.left + 'px';
                } else if (Math.abs(elTop - pos2.top) < 2 && Math.abs(elLeft - pos2.left) < 2) {
                    el.style.top = pos1.top + 'px';
                    el.style.left = pos1.left + 'px';
                }
            }

            // Swap in grid
            var tmp = grid[r1][c1];
            grid[r1][c1] = grid[r2][c2];
            grid[r2][c2] = tmp;
            puState.swap--;
            puSelectMode = null;
            puSwapFirst = null;
            gameBoard.classList.remove('selecting');

            setTimeout(function () {
                animating = false;
                renderTiles(null, null);
                updatePowerupBar();
                savePuState();
                saveState();
            }, 220);
        }

        // Check if player earned a demolish powerup (every 3000 score)
        function checkPuRewards(scoreBeforeMove) {
            if (!powerupsEnabled) return;
            var DEMOLISH_INTERVAL = 3000;
            var DEMOLISH_MAX = 3;
            var oldMilestone = Math.floor(scoreBeforeMove / DEMOLISH_INTERVAL);
            var newMilestone = Math.floor(score / DEMOLISH_INTERVAL);
            if (newMilestone > oldMilestone && puState.demolish < DEMOLISH_MAX) {
                var gained = Math.min(newMilestone - oldMilestone, DEMOLISH_MAX - puState.demolish);
                puState.demolish += gained;
                puState.lastScoreMilestone = newMilestone * DEMOLISH_INTERVAL;
                showPuGainedAnim('pu-demolish');
                savePuState();
            }
            updatePowerupBar();
        }

        function showPuGainedAnim(btnId) {
            var btn = document.getElementById(btnId);
            var anim = document.createElement('span');
            anim.className = 'pu-gained-anim';
            anim.textContent = t('powerupGained');
            btn.appendChild(anim);
            setTimeout(function () { if (anim.parentNode) anim.parentNode.removeChild(anim); }, 900);
        }

        function savePuState() {
            localStorage.setItem('game4096_puState', JSON.stringify(puState));
        }

        function loadPuState() {
            var saved = localStorage.getItem('game4096_puState');
            if (saved) {
                try {
                    var s = JSON.parse(saved);
                    puState.demolish = s.demolish || 0;
                    puState.swap = s.swap || 0;
                    puState.lastScoreMilestone = s.lastScoreMilestone || 0;
                } catch (e) {}
            }
        }

        function resetPuState() {
            puState = { demolish: 0, swap: 2, lastScoreMilestone: 0 };
            puSelectMode = null;
            puSwapFirst = null;
            gameBoard.classList.remove('selecting');
            savePuState();
            updatePowerupBar();
        }

        // Event listeners for powerup buttons
        puDemolishBtn.addEventListener('click', function () { startPuSelect('demolish'); });
        puSwapBtn.addEventListener('click', function () { startPuSelect('swap'); });
        puCancelBtn.addEventListener('click', cancelPuSelect);
        document.getElementById('powerup-btn').addEventListener('click', togglePowerups);

        // ===== Game Logic =====
        const SIZE = 4;
        const WIN_VALUE = 4096;
        const ANIM_DURATION = 150;

        let grid, score, bestScore, previousState, won, over, keepPlaying;
        let animating = false;

        const tileContainer = document.getElementById('tile-container');
        const scoreEl = document.getElementById('score');
        const bestScoreEl = document.getElementById('best-score');
        const overlay = document.getElementById('overlay');
        const overlayMessage = document.getElementById('overlay-message');
        const overlayBtn = document.getElementById('overlay-btn');
        const newGameBtn = document.getElementById('new-game-btn');
        const undoBtn = document.getElementById('undo-btn');
        const gameBoard = document.getElementById('game-board');
        const gridBg = document.getElementById('grid-bg');

        // --- Helpers ---
        function emptyGrid() {
            return Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
        }

        function cloneGrid(g) {
            return g.map(row => [...row]);
        }

        function emptyCells(g) {
            const cells = [];
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++)
                    if (g[r][c] === 0) cells.push([r, c]);
            return cells;
        }

        function addRandomTile(g) {
            const cells = emptyCells(g);
            if (cells.length === 0) return;
            const [r, c] = cells[Math.floor(Math.random() * cells.length)];
            g[r][c] = Math.random() < 0.9 ? 2 : 4;
            return [r, c, g[r][c]];
        }

        // --- Core move logic ---
        function slideRow(row) {
            const items = [];
            for (let i = 0; i < row.length; i++) {
                if (row[i] !== 0) items.push({ val: row[i], from: i });
            }

            const result = Array(SIZE).fill(0);
            let sc = 0;
            const moves = [];
            const mergeTargets = [];
            let pos = 0;

            for (let i = 0; i < items.length; i++) {
                if (i < items.length - 1 && items[i].val === items[i + 1].val) {
                    result[pos] = items[i].val * 2;
                    sc += result[pos];
                    moves.push({ from: items[i].from, to: pos });
                    moves.push({ from: items[i + 1].from, to: pos });
                    mergeTargets.push(pos);
                    i++;
                } else {
                    result[pos] = items[i].val;
                    moves.push({ from: items[i].from, to: pos });
                }
                pos++;
            }

            const moved = row.some((v, i) => v !== result[i]);
            return { row: result, score: sc, moved, moves, mergeTargets };
        }

        function rotateGrid(g, times) {
            let result = cloneGrid(g);
            for (let t = 0; t < times; t++) {
                const tmp = emptyGrid();
                for (let r = 0; r < SIZE; r++)
                    for (let c = 0; c < SIZE; c++)
                        tmp[c][SIZE - 1 - r] = result[r][c];
                result = tmp;
            }
            return result;
        }

        // Inverse-rotate a position: convert rotated-space coords back to original-space
        function inverseRotatePos(r, c, rot) {
            let nr = r, nc = c;
            for (let t = 0; t < (4 - rot) % 4; t++) {
                const tmp = nc;
                nc = SIZE - 1 - nr;
                nr = tmp;
            }
            return [nr, nc];
        }

        // dir: 0=left, 1=up, 2=right, 3=down
        // Correct rotation counts: left=0, up=3, right=2, down=1
        const DIR_ROTATIONS = [0, 3, 2, 1];

        function move(g, dir) {
            const rot = DIR_ROTATIONS[dir];
            let rotated = rotateGrid(g, rot);
            let totalScore = 0;
            let moved = false;
            const allMoves = [];
            const mergedPositions = [];

            for (let r = 0; r < SIZE; r++) {
                const result = slideRow(rotated[r]);
                if (result.moved) moved = true;
                totalScore += result.score;
                rotated[r] = result.row;

                for (const m of result.moves) {
                    const [fromR, fromC] = inverseRotatePos(r, m.from, rot);
                    const [toR, toC] = inverseRotatePos(r, m.to, rot);
                    allMoves.push({ fromR, fromC, toR, toC });
                }

                for (const col of result.mergeTargets) {
                    const [origR, origC] = inverseRotatePos(r, col, rot);
                    mergedPositions.push([origR, origC]);
                }
            }

            const finalGrid = rotateGrid(rotated, (4 - rot) % 4);

            return { grid: finalGrid, score: totalScore, moved, merges: mergedPositions, moves: allMoves };
        }

        function canMove(g) {
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++) {
                    if (g[r][c] === 0) return true;
                    if (c < SIZE - 1 && g[r][c] === g[r][c + 1]) return true;
                    if (r < SIZE - 1 && g[r][c] === g[r + 1][c]) return true;
                }
            return false;
        }

        function hasWon(g) {
            for (let r = 0; r < SIZE; r++)
                for (let c = 0; c < SIZE; c++)
                    if (g[r][c] >= WIN_VALUE) return true;
            return false;
        }

        // --- Rendering ---
        let tileSizeW, tileSizeH, gapW, gapH, originX, originY;

        function computeSizes() {
            var cells = gridBg.children;
            var containerRect = tileContainer.getBoundingClientRect();
            var c0 = cells[0].getBoundingClientRect();
            var c1 = cells[1].getBoundingClientRect();
            var c4 = cells[4].getBoundingClientRect();

            tileSizeW = c0.width;
            tileSizeH = c0.height;
            gapW = c1.left - c0.right;
            gapH = c4.top - c0.bottom;
            originX = c0.left - containerRect.left;
            originY = c0.top - containerRect.top;
        }

        function tilePos(row, col) {
            return {
                top: originY + row * (tileSizeH + gapH),
                left: originX + col * (tileSizeW + gapW),
            };
        }

        function fontSizeForValue(val) {
            var s = Math.min(tileSizeW, tileSizeH);
            if (val < 100) return s * 0.45;
            if (val < 1000) return s * 0.38;
            return s * 0.30;
        }

        function createTileEl(val, r, c, extraClass) {
            const pos = tilePos(r, c);
            const el = document.createElement('div');
            const tileClass = val <= 8192 ? 'tile-' + val : 'tile-8192';
            el.className = 'tile ' + tileClass + (extraClass ? ' ' + extraClass : '');
            el.textContent = val;
            el.style.width = tileSizeW + 'px';
            el.style.height = tileSizeH + 'px';
            el.style.top = pos.top + 'px';
            el.style.left = pos.left + 'px';
            el.style.fontSize = fontSizeForValue(val) + 'px';
            el.style.lineHeight = tileSizeH + 'px';
            return el;
        }

        // Instant render (no animation) â€” used for undo, new game, load
        function renderTiles(newTile, merges) {
            tileContainer.innerHTML = '';
            computeSizes();

            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const val = grid[r][c];
                    if (val === 0) continue;

                    let extraClass = '';
                    if (newTile && newTile[0] === r && newTile[1] === c) extraClass = 'tile-new';
                    if (merges && merges.some(function (m) { return m[0] === r && m[1] === c; })) extraClass = 'tile-merged';

                    tileContainer.appendChild(createTileEl(val, r, c, extraClass));
                }
            }
        }

        // Animated render â€” tiles slide from old positions to new positions
        function animateMove(oldGrid, movements, newTile, merges) {
            animating = true;
            tileContainer.innerHTML = '';
            computeSizes();

            var tileEls = [];
            var transitionVal = 'top ' + ANIM_DURATION + 'ms ease-in-out, left ' + ANIM_DURATION + 'ms ease-in-out';

            // Create tiles at their OLD positions
            for (var i = 0; i < movements.length; i++) {
                var m = movements[i];
                var val = oldGrid[m.fromR][m.fromC];
                var el = createTileEl(val, m.fromR, m.fromC, '');
                el.style.transition = transitionVal;
                tileContainer.appendChild(el);
                tileEls.push({ el: el, toR: m.toR, toC: m.toC });
            }

            // Force reflow so browser registers initial positions
            tileContainer.offsetHeight;

            // Animate to NEW positions
            for (var j = 0; j < tileEls.length; j++) {
                var pos = tilePos(tileEls[j].toR, tileEls[j].toC);
                tileEls[j].el.style.top = pos.top + 'px';
                tileEls[j].el.style.left = pos.left + 'px';
            }

            // After animation completes, do final render with merged/new tile effects
            setTimeout(function () {
                renderTiles(newTile, merges);
                animating = false;
            }, ANIM_DURATION);
        }

        function updateScore() {
            scoreEl.textContent = score;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('best4096', bestScore);
            }
            bestScoreEl.textContent = bestScore;
        }

        function showOverlay(msg, isWin) {
            overlayMessage.textContent = msg;
            overlay.className = 'overlay active' + (isWin ? ' win' : '');
            overlayBtn.textContent = isWin ? t('keepPlaying') : t('playAgain');
        }

        function hideOverlay() {
            overlay.className = 'overlay';
        }

        // --- Game flow ---
        function newGame() {
            grid = emptyGrid();
            score = 0;
            won = false;
            over = false;
            keepPlaying = false;
            previousState = null;
            animating = false;
            hideOverlay();

            addRandomTile(grid);
            const second = addRandomTile(grid);
            updateScore();
            renderTiles(second ? second : null, null);
            resetPuState();
            saveState();
        }

        function saveState() {
            localStorage.setItem('game4096', JSON.stringify({ grid, score, won, over, keepPlaying }));
        }

        function loadState() {
            const saved = localStorage.getItem('game4096');
            if (saved) {
                try {
                    const s = JSON.parse(saved);
                    grid = s.grid;
                    score = s.score;
                    won = s.won || false;
                    over = s.over || false;
                    keepPlaying = s.keepPlaying || false;
                    previousState = null;
                    updateScore();
                    renderTiles(null, null);
                    if (over) showOverlay(t('gameOver'), false);
                    return true;
                } catch (e) { /* ignore */ }
            }
            return false;
        }

        function handleMove(dir) {
            if (over && !keepPlaying) return;
            if (animating) return;
            if (settingsOpen) return;
            if (puSelectMode) return; // block moves during powerup selection

            const result = move(grid, dir);
            if (!result.moved) return;

            playMoveSFX();

            // Save for undo (before applying move)
            var scoreBeforeMove = score;
            const oldGrid = cloneGrid(grid);
            previousState = { grid: oldGrid, score: score, puState: JSON.parse(JSON.stringify(puState)) };

            grid = result.grid;
            score += result.score;

            const newTile = addRandomTile(grid);
            updateScore();

            // Animate tiles sliding, then show new tile
            animateMove(oldGrid, result.moves, newTile, result.merges);

            // Check powerup rewards after score update
            checkPuRewards(scoreBeforeMove);

            if (!won && hasWon(grid)) {
                won = true;
                setTimeout(function () { showOverlay(t('youWin'), true); }, ANIM_DURATION + 50);
            } else if (!canMove(grid)) {
                over = true;
                setTimeout(function () { showOverlay(t('gameOver'), false); }, ANIM_DURATION + 50);
            }

            saveState();
        }

        function undo() {
            if (!previousState) return;
            if (animating) return;
            grid = previousState.grid;
            score = previousState.score;
            if (previousState.puState) {
                puState = previousState.puState;
                savePuState();
                updatePowerupBar();
            }
            previousState = null;
            won = false;
            over = false;
            hideOverlay();
            updateScore();
            renderTiles(null, null);
            saveState();
        }

        // --- Input handling ---
        // Keyboard
        document.addEventListener('keydown', function (e) {
            if (settingsOpen) return;

            const keyMap = {
                ArrowLeft: 0, a: 0, A: 0,
                ArrowUp: 1, w: 1, W: 1,
                ArrowRight: 2, d: 2, D: 2,
                ArrowDown: 3, s: 3, S: 3,
            };

            if (e.key in keyMap) {
                e.preventDefault();
                handleMove(keyMap[e.key]);
            }

            // Escape to cancel powerup selection
            if (e.key === 'Escape' && puSelectMode) {
                cancelPuSelect();
                return;
            }

            // Ctrl+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
        });

        // Touch / pointer
        let touchStartX, touchStartY;
        const SWIPE_THRESHOLD = 30;

        gameBoard.addEventListener('touchstart', function (e) {
            if (settingsOpen) return;
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: true });

        gameBoard.addEventListener('touchend', function (e) {
            if (settingsOpen) return;
            if (touchStartX == null) return;
            var endX = e.changedTouches[0].clientX;
            var endY = e.changedTouches[0].clientY;
            const dx = endX - touchStartX;
            const dy = endY - touchStartY;
            touchStartX = null;

            var isTap = Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD;

            if (isTap && puSelectMode) {
                // Handle as tile selection tap
                computeSizes();
                var boardRect = tileContainer.getBoundingClientRect();
                var x = endX - boardRect.left;
                var y = endY - boardRect.top;
                for (var r = 0; r < SIZE; r++) {
                    for (var c = 0; c < SIZE; c++) {
                        var pos = tilePos(r, c);
                        if (x >= pos.left && x <= pos.left + tileSizeW &&
                            y >= pos.top && y <= pos.top + tileSizeH) {
                            handleTileClick(r, c);
                            return;
                        }
                    }
                }
                return;
            }

            if (isTap) return;

            if (Math.abs(dx) > Math.abs(dy)) {
                handleMove(dx > 0 ? 2 : 0);
            } else {
                handleMove(dy > 0 ? 3 : 1);
            }
        }, { passive: true });

        // Mouse drag support for desktop
        let mouseDown = false;
        gameBoard.addEventListener('mousedown', function (e) {
            if (settingsOpen) return;
            mouseDown = true;
            touchStartX = e.clientX;
            touchStartY = e.clientY;
        });

        document.addEventListener('mouseup', function (e) {
            if (!mouseDown) return;
            mouseDown = false;
            const dx = e.clientX - touchStartX;
            const dy = e.clientY - touchStartY;

            if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) return;

            if (Math.abs(dx) > Math.abs(dy)) {
                handleMove(dx > 0 ? 2 : 0);
            } else {
                handleMove(dy > 0 ? 3 : 1);
            }
        });

        // Buttons
        newGameBtn.addEventListener('click', newGame);
        overlayBtn.addEventListener('click', function () {
            if (won && !keepPlaying) {
                keepPlaying = true;
                hideOverlay();
                saveState();
            } else {
                newGame();
            }
        });
        undoBtn.addEventListener('click', undo);

        // --- Powerup tile selection via click/tap on game board ---
        gameBoard.addEventListener('click', function (e) {
            if (!puSelectMode) return;
            // Find which grid cell was clicked
            computeSizes();
            var boardRect = tileContainer.getBoundingClientRect();
            var x = e.clientX - boardRect.left;
            var y = e.clientY - boardRect.top;

            // Determine row and col from click position
            for (var r = 0; r < SIZE; r++) {
                for (var c = 0; c < SIZE; c++) {
                    var pos = tilePos(r, c);
                    if (x >= pos.left && x <= pos.left + tileSizeW &&
                        y >= pos.top && y <= pos.top + tileSizeH) {
                        handleTileClick(r, c);
                        return;
                    }
                }
            }
        });

        // --- Gamepad support (PS5 / Xbox / generic controllers) ---
        var gamepadConnected = false;
        var gamepadPrevButtons = {};
        var gamepadPrevAxis = { x: 0, y: 0 };
        var STICK_THRESHOLD = 0.5;

        window.addEventListener('gamepadconnected', function () {
            gamepadConnected = true;
        });
        window.addEventListener('gamepaddisconnected', function () {
            gamepadConnected = false;
        });

        function pollGamepad() {
            if (!gamepadConnected) {
                requestAnimationFrame(pollGamepad);
                return;
            }

            if (settingsOpen) {
                requestAnimationFrame(pollGamepad);
                return;
            }

            var gamepads = navigator.getGamepads();
            for (var gi = 0; gi < gamepads.length; gi++) {
                var gp = gamepads[gi];
                if (!gp || !gp.connected) continue;

                // D-pad (buttons 12=up, 13=down, 14=left, 15=right)
                var dpadMap = { 12: 1, 13: 3, 14: 0, 15: 2 };
                for (var btn in dpadMap) {
                    var pressed = gp.buttons[btn] && gp.buttons[btn].pressed;
                    var key = gi + '_' + btn;
                    if (pressed && !gamepadPrevButtons[key]) {
                        handleMove(dpadMap[btn]);
                    }
                    gamepadPrevButtons[key] = pressed;
                }

                // Left stick
                var ax = gp.axes[0] || 0;
                var ay = gp.axes[1] || 0;
                var prevAx = gamepadPrevAxis.x;
                var prevAy = gamepadPrevAxis.y;

                if (Math.abs(ax) > Math.abs(ay) && Math.abs(ax) > STICK_THRESHOLD) {
                    if (Math.abs(prevAx) <= STICK_THRESHOLD) {
                        handleMove(ax > 0 ? 2 : 0);
                    }
                } else if (Math.abs(ay) > STICK_THRESHOLD) {
                    if (Math.abs(prevAy) <= STICK_THRESHOLD) {
                        handleMove(ay > 0 ? 3 : 1);
                    }
                }
                gamepadPrevAxis.x = ax;
                gamepadPrevAxis.y = ay;

                // A/Cross (button 0) â†’ confirm / new game when overlay is shown
                var aPressed = gp.buttons[0] && gp.buttons[0].pressed;
                var aKey = gi + '_0';
                if (aPressed && !gamepadPrevButtons[aKey]) {
                    if (overlay.classList.contains('active')) {
                        overlayBtn.click();
                    }
                }
                gamepadPrevButtons[aKey] = aPressed;

                // B/Circle (button 1) â†’ undo
                var bPressed = gp.buttons[1] && gp.buttons[1].pressed;
                var bKey = gi + '_1';
                if (bPressed && !gamepadPrevButtons[bKey]) {
                    undo();
                }
                gamepadPrevButtons[bKey] = bPressed;

                break; // Use first connected gamepad only
            }

            requestAnimationFrame(pollGamepad);
        }
        requestAnimationFrame(pollGamepad);

        // Handle resize â€” debounce to let CSS layout settle after orientation change
        var resizeTimer;
        window.addEventListener('resize', function () {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function () {
                if (!animating) renderTiles(null, null);
            }, 150);
        });

        // --- Init ---
        // Set real viewport height CSS variable for mobile browser address bar
        function updateAppVH() {
            document.documentElement.style.setProperty('--app-vh', window.innerHeight + 'px');
        }
        updateAppVH();
        window.addEventListener('resize', updateAppVH);

        bestScore = parseInt(localStorage.getItem('best4096')) || 0;

        // Detect and apply language before loading game state
        currentLang = detectLanguage();
        applyLanguage(currentLang);

        loadPuState();
        updatePowerupBar();

        if (!loadState()) {
            newGame();
        }
    })();
    </script>
</body>
</html>
